[
  {
    "id": "a77fd95bde1f6768",
    "title": "Customize AI agent browsing with proxies, profiles, and extensions in Amazon Bedrock AgentCore Browser",
    "url": "https://aws.amazon.com/blogs/machine-learning/customize-ai-agent-browsing-with-proxies-profiles-and-extensions-in-amazon-bedrock-agentcore-browser/",
    "source_name": "Amazon AWS ML",
    "source_category": "ai",
    "language": "en",
    "published": "2026-02-13T22:57:34Z",
    "summary": "Today, we are announcing three new capabilities that address these requirements: proxy configuration, browser profiles, and browser extensions. Together, these features give you fine-grained control over how your AI agents interact with the web. This post will walk through each capability with configuration examples and practical use cases to help you get started.",
    "content": "AI agents that browse the web need more than basic page navigation. Our customers tell us they need agents that maintain session state across interactions, route traffic through corporate proxy infrastructure, and run with custom browser configurations. AgentCore Browser provides a secure, isolated browser environment for your agents to interact with web applications. Until now, in Agent Core Browser, each browser session started from a blank slate with default settings and direct internet access, limiting what agents could accomplish in real-world enterprise environments.\nToday, we are announcing three new capabilities that address these requirements: proxy configuration , browser profiles , and browser extensions . Together, these features give you fine-grained control over how your AI agents interact with the web.\nThese three capabilities give you control over how AgentCore Browser sessions connect to the internet, what state they retain, and how they behave. Proxy configuration lets you route browser traffic through your own proxy servers, providing IP stability and integration with corporate network infrastructure. Browser profiles persist cookies and local storage across sessions, so agents can resume authenticated workflows without repeating login flows. Browser extensions load Chrome extensions into sessions to customize browser behavior for your use case. This post will walk through each capability with configuration examples and practical use cases to help you get started.\nHow persistent browser profiles keep AI Agents running smoothly\nCustomers building agents for e-commerce testing, authenticated workflows, and multi-step user journeys need browser sessions that remember state. Without persistent profiles, agents are required to re-authenticate and rebuild context at the start of every session, adding latency and fragility to automated workflows. Browser profiles solve this by saving and restoring cookies and local storage between sessions, so an agent that logged into a portal yesterday can pick up where it left off today.\nIP stability is another common requirement. Healthcare and financial portals validate sessions based on source IP address, and rotating AWS IP addresses cause frequent re-authentication cycles that break long-running workflows. Proxy support lets you route traffic through servers with stable egress IPs, maintaining session continuity and meeting IP allowlisting requirements. Organizations that route traffic through corporate proxies need to extend this practice to AI agents for browser sessions. Proxy configuration enables access to internal webpages and resources that require proxy-based connectivity.\nBrowser extensions allow custom configurations such as ad blocking, authentication helpers, or other browser-level customization. When combined with proxy logging, these capabilities helps provide access control and audit evidence that may  support  compliance programs  such as FedRAMP, HITRUST, and PCI .  \nFeature 1: Proxy configuration\nAgentCore Browser  now supports routing browser traffic through your own external proxy servers. When you create a browser session with proxy configuration, AgentCore configures the browser to route HTTP and HTTPS traffic through your specified proxy servers.\nHow it works\nYou call StartBrowserSession with a proxyConfiguration specifying your proxy server. If using authentication, AgentCore retrieves proxy credentials from AWS Secrets Manager. The browser session starts with your proxy configuration applied, and browser traffic routes through your proxy server based on your domain routing rules.\nGetting started with proxies\nComplete these prerequisites before proceeding.\nStep 1: Create a credentials secret (if your proxy requires authentication)\n\nimport boto3\nimport json\nclient = boto3.client('secretsmanager')\nclient.create_secret(\nName='my-proxy-credentials',\nSecretString=json.dumps({\n'username': '<your-username>',\n'password': '<your-password>'\n})\n)\n\nStep 2: Create a browser session with proxy configuration  \n\nsession_client = boto3.client('bedrock-agentcore', region_name='<region>')\n\nresponse = session_client.start_browser_session(\nbrowserIdentifier=\"aws.browser.v1\",\nname=\"my-proxy-session\",\nproxyConfiguration={\n\"proxies\": [{\n\"externalProxy\": {\n\"server\": \"<your-proxy-hostname>\",\n\"port\": 8080,\n\"credentials\": {\n\"basicAuth\": {\n\"secretArn\": \"arn:aws:secretsmanager:<region>:<account-id>:secret:<secret-name>\"\n}\n}\n}\n}]\n}\n)\nprint(f\"Session ID: {response['sessionId']}\")\n\nThe credentials field is optional for proxies without authentication.\nDomain-based routing\nUse domainPatterns to route specific domains through designated proxies, and bypass.domainPatterns for domains that should connect directly:\n\nproxyConfiguration={\n\"proxies\": [\n{\n\"externalProxy\": {\n\"server\": \"corp-proxy.example.com\",\n\"port\": 8080,\n\"domainPatterns\": [\".company.com\", \".internal.corp\"]\n}\n},\n{\n\"externalProxy\": {\n\"server\": \"general-proxy.example.com\",\n\"port\": 8080\n}\n}\n],\n\"bypass\": {\n\"domainPatterns\": [\".amazonaws.com\"]\n}\n}\n\nWith this configuration, requests to  *.company.com  and  *. internal.corp   route through the corporate  proxy,   requests  to  *. amazonaws.com   bypass all proxies , and everything else routes through the general proxy.  Th e s e fields   are  just an example.  Bypass domains  can match  bypass.domainPatterns  to connect directly and  external  proxy   can be a  valid  proxy’s   domainPatterns   route through that proxy (first match wins based on array order).  \nRouting precedence\nWhen AgentCore Browser processes an outbound request, it walks through three tiers of routing rules to decide where to send the traffic. It first checks the bypass list. If the destination domain matches a bypass.domainPatterns entry, the request connects directly to the internet without using any proxy. If the domain does not match a bypass rule, AgentCore checks each proxy’s domainPatterns in order and routes the request through the first proxy whose pattern matches. If no proxy pattern matches either, the request falls through to the default proxy, which is the proxy entry that has no domainPatterns defined.\nTest the new proxy feature with this code example .\nFeature 2: Browser profiles\nBrowser profiles let you persist and reuse session data across multiple browser sessions, including cookies and local storage. An agent that authenticates with a web portal in one session can restore that state in a later session without logging in again. This is useful for authenticated workflows where re-login adds latency, e-commerce testing where shopping carts and form data need to survive between sessions, and multi-step user journeys that span multiple browser invocations.\nThe profile lifecycle has four stages. You start by calling create_browser_profile() to create a named profile. At the end of a session, you call save_browser_session_profile() to capture the current cookies and local storage into that profile. When you start a new session, you pass the profile identifier in the profileConfiguration parameter of start_browser_session() , which restores the saved state into the new browser. When you no longer need the profile, you call delete_browser_profile() to clean it up.\nThe following example shows an agent that adds items to a shopping cart in one session and verifies they persist in a subsequent session.\nComplete these prerequisites before proceeding.\n\nimport boto3\n\ncontrol_client = boto3.client('bedrock-agentcore-control', region_name='<region>') # replace by your region\n\nsession_client = boto3.client('bedrock-agentcore', region_name='<region>') # replace by your region\n\n# Create a browser profile\nprofile = control_client.create_browser_profile(name=\"ecommerce_profile\")\nprofile_id = profile['profileId']\n\n# Session 1: Add items to cart\nsession1 = session_client.start_browser_session(\nbrowserIdentifier=”aws.browser.v1”,\nname=\"shopping-session-1\"\n)\n# ... agent navigates and adds items to cart ...\n\n# Save session state to profile\nsession_client.save_browser_session_profile(\nsessionId=session1['sessionId'],\nbrowserIdentifier=”aws.browser.v1”,\nprofileIdentifier=profile_id\n)\nsession_client.stop_browser_session(sessionId=session1['sessionId'], browserIdentifier=\"aws.browser.v1\")\n\n# Session 2: Resume with saved profile\nsession2 = session_client.start_browser_session(\nbrowserIdentifier=”aws.browser.v1”,\nname=\"shopping-session-2\",\nprofileConfiguration={\"profileIdentifier\": profile_id}\n)\n# Cart items from Session 1 are now available\n\nTest the new profile feature with this code example .\nFeature 3: Browser extensions\nBrowser extensions let you load Chrome extensions into AgentCore Browser sessions to customize how the browser behaves. You package extensions as ZIP files, upload them to Amazon Simple Storage Service (Amazon S3), and reference them when starting a browser session. This provides access to functionality available through the Chrome extension API, from proxy routing and ad blocking to authentication helpers and content modification. For example, you can inject authentication tokens for internal applications, remove ads, and track scripts that interfere with agent navigation, or modify page content to improve how agents interact with a site.\nYour extension should follow the standard Chromium extension format and adhere to Chromium extension guidelines.\nComplete these prerequisites before proceeding.\n\nUpload the extension to Amazon S3:\n\n# Upload extension to S3\n\nimport boto3\ns3 = boto3.client('s3')\ns3.upload_file(\n'my-extension.zip',\n'amzn-s3-demo-bucket-extensions',\n'extensions/my-extension.zip'\n)\n\nThen, start a session with the extension, pointing to the Amazon S3 bucket where you’ve uploaded the zip file:\n\nimport boto3\nregion = \"<region>\" # replace by your region\nclient = boto3.client('bedrock-agentcore', region_name=region)\n\nresponse = client.start_browser_session(\nbrowserIdentifier=\"aws.browser.v1\",\nname=\"my-session-with-extensions\",\nsessionTimeoutSeconds=1800,\nviewPort={\n'height': 1080,\n'width': 1920\n},\nextensions=[\n{\n\"location\": {\n\"s3\": {\n\"bucket\": \"amzn-s3-demo-bucket-extensions\",\n\"prefix\": \"extensions/my-extension.zip\"\n}\n}\n},\n{\n\"location\": {\n\"s3\": {\n\"bucket\": \"amzn-s3-demo-bucket-extensions\",\n\"prefix\": \"extensions/another-extension.zip\",\n\"versionId\": \"abc123\" # Optional - for versioned S3 buckets\n}\n}\n}\n]\n)\n\nprint(f\"Session ID: {response['sessionId']}\")\nprint(f\"Status: {response['status']}\")\nprint(f\"Automation Stream: {response['streams']['automationStream']['streamEndpoint']}\")\n\nTest the new extensions feature with this code example .\nConclusion\nProxy configuration, browser profiles, and browser extensions give AgentCore Browser the proxy routing, session persistence, and extensibility controls that customers need to deploy AI agents that browse the web in production. You can route traffic through your corporate proxy infrastructure, maintain session continuity across interactions, and customize browser behavior with extensions, all while keeping credentials secure in AWS Secrets Manager. Customers can carry e-commerce context and information among sessions, create your own extension and test it in a secure environment before release, and, also, have browser connecting into your network through proxies.  \nTo get started, see the tutorials in the  Amazon Bedrock AgentCore samples  repository and the Amazon Bedrock AgentCore Browser  documentation .   For more information about pricing, visit  Amazon Bedrock AgentCore Pricing .  \n\nAbout the Authors\n\nJoshua Samuel\nJoshua Samuel is a Senior AI/ML Specialist Solutions Architect at AWS who accelerates enterprise transformation through AI/ML, and generative AI solutions, based in Melbourne, Australia. A passionate disrupter, he specializes in agentic AI and coding techniques – Anything that makes builders faster and happier. Outside work, he tinkers with home automation and AI coding projects, and enjoys life with his wife, kids and dog.\n\nEvandro Franco\nEvandro Franco is a Sr. Data Scientist working on Amazon Web Services. He is part of the Global GTM team that helps AWS customers overcome business challenges related to AI/ML on top of AWS, mainly on Amazon Bedrock AgentCore and Strands Agents. He has more than 18 years of experience working with technology, from software development, infrastructure, serverless, to machine learning. In his free time, Evandro enjoys playing with his son, mainly building some funny Lego bricks.\n\nKosti Vasilakakis\nKosti Vasilakakis is a Principal PM at AWS on the Agentic AI team, where he has led the design and development of several Bedrock AgentCore services from the ground up, including Runtime, Browser, Code Interpreter, and Identity. He previously worked on Amazon SageMaker since its early days, launching AI/ML capabilities now used by thousands of companies worldwide. Earlier in his career, Kosti was a data scientist. Outside of work, he builds personal productivity automations, plays tennis, and enjoys life with his wife and kids.\n\nYan Marim\nYan Marim is a Sr. GenAI Specialist Solutions Architect at Amazon Web Services, based in Brazil. As part of the LATAM Specialist team, he guides customers through their generative AI adoption journey, focusing on Amazon Bedrock and agentic AI solutions. In his free time, Yan enjoys spending quality time with his wife and dog, and watching soccer games.\n\nKevin Orellana\nKevin Orellana is a Software Development Engineer at Amazon Web Services on the Bedrock AgentCore team, based in Seattle. He builds and operates core infrastructure powering agentic AI capabilities, including Browser, Code Interpreter, and Runtime. Earlier in his career, Kevin worked on the Bedrock inference team hosting frontier models. In his free time, he enjoys hiking with his Goldendoodle, experimenting with multi-agent simulations, and working toward building a personal AI assistant that speaks English, Spanish, and Mandarin.",
    "weight": 0.85,
    "fetch_type": "rss",
    "company": "amazon",
    "light_analysis": null,
    "analyzed_at": null,
    "analysis_status": "failed",
    "analysis_error": "Error code: 402 - {'error': {'message': 'Insufficient Balance', 'type': 'unknown_error', 'param': None, 'code': 'invalid_request_error'}}"
  },
  {
    "id": "f01e7b0996ca2c65",
    "title": "GPT-5.2 derives a new result in theoretical physics",
    "url": "https://openai.com/index/new-result-theoretical-physics",
    "source_name": "OpenAI",
    "source_category": "ai",
    "language": "en",
    "published": "2026-02-13T11:00:00Z",
    "summary": "A new preprint shows GPT-5.2 proposing a new formula for a gluon amplitude, later formally proved and verified by OpenAI and academic collaborators.",
    "content": "A new preprint shows GPT-5.2 proposing a new formula for a gluon amplitude, later formally proved and verified by OpenAI and academic collaborators.",
    "weight": 1.0,
    "fetch_type": "rss",
    "company": "openai",
    "light_analysis": null,
    "analyzed_at": null,
    "analysis_status": "failed",
    "analysis_error": "Error code: 402 - {'error': {'message': 'Insufficient Balance', 'type': 'unknown_error', 'param': None, 'code': 'invalid_request_error'}}"
  },
  {
    "id": "4fafadd15590fd4d",
    "title": "Introducing Lockdown Mode and Elevated Risk labels in ChatGPT",
    "url": "https://openai.com/index/introducing-lockdown-mode-and-elevated-risk-labels-in-chatgpt",
    "source_name": "OpenAI",
    "source_category": "ai",
    "language": "en",
    "published": "2026-02-13T10:00:00Z",
    "summary": "Introducing Lockdown Mode and Elevated Risk labels in ChatGPT to help organizations defend against prompt injection and AI-driven data exfiltration.",
    "content": "Introducing Lockdown Mode and Elevated Risk labels in ChatGPT to help organizations defend against prompt injection and AI-driven data exfiltration.",
    "weight": 1.0,
    "fetch_type": "rss",
    "company": "openai",
    "light_analysis": null,
    "analyzed_at": null,
    "analysis_status": "failed",
    "analysis_error": "Error code: 402 - {'error': {'message': 'Insufficient Balance', 'type': 'unknown_error', 'param': None, 'code': 'invalid_request_error'}}"
  },
  {
    "id": "2beba19a0ac89567",
    "title": "Beyond rate limits: scaling access to Codex and Sora",
    "url": "https://openai.com/index/beyond-rate-limits",
    "source_name": "OpenAI",
    "source_category": "ai",
    "language": "en",
    "published": "2026-02-13T09:00:00Z",
    "summary": "How OpenAI built a real-time access system combining rate limits, usage tracking, and credits to power continuous access to Sora and Codex.",
    "content": "How OpenAI built a real-time access system combining rate limits, usage tracking, and credits to power continuous access to Sora and Codex.",
    "weight": 1.0,
    "fetch_type": "rss",
    "company": "openai",
    "light_analysis": null,
    "analyzed_at": null,
    "analysis_status": "failed",
    "analysis_error": "Error code: 402 - {'error': {'message': 'Insufficient Balance', 'type': 'unknown_error', 'param': None, 'code': 'invalid_request_error'}}"
  },
  {
    "id": "ab9909aef08da6ec",
    "title": "Scaling social science research",
    "url": "https://openai.com/index/scaling-social-science-research",
    "source_name": "OpenAI",
    "source_category": "ai",
    "language": "en",
    "published": "2026-02-13T09:00:00Z",
    "summary": "GABRIEL is a new open-source toolkit from OpenAI that uses GPT to turn qualitative text and images into quantitative data, helping social scientists analyze research at scale.",
    "content": "GABRIEL is a new open-source toolkit from OpenAI that uses GPT to turn qualitative text and images into quantitative data, helping social scientists analyze research at scale.",
    "weight": 1.0,
    "fetch_type": "rss",
    "company": "openai",
    "light_analysis": null,
    "analyzed_at": null,
    "analysis_status": "failed",
    "analysis_error": "Error code: 402 - {'error': {'message': 'Insufficient Balance', 'type': 'unknown_error', 'param': None, 'code': 'invalid_request_error'}}"
  }
]